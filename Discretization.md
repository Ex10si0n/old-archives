---
title: 「离散化」简单好用的一种数学模型处理思想

date: 2017-08-24 21:33

tags: [离散化]

categories: C++

thumbnail: https://wallpapers.wallhaven.cc/wallpapers/full/wallhaven-507876.png
---

## 简介

**什么是离散？**

我们好比在看地图时，放大或缩小时候的一种放缩感，换句话说，就是把一个巨大的空间中的数据映射到唯一一个小的编号中（哈希Hash），离散主要提高了空间利用率，降低时间，可谓一举两得，写起来也很方便，**但是**不是所有数据都能或者说都值得离散化的。我们看一下[POJ-2502 Subway](http://ex10si0n.com/2017/08/20/POJ2502/)这道题的存图，显然他需要坐标进行计算得到距离，如果离散的话，那么就会导致距离错误。而Vijos 1056就是一道离散化的题，那么总而言之，离散化就是将大数据，巨型图压缩到利用率达到100%的一个哈希表，参考高中数学的映射，说白了就是缩小数据，这样您能更好的理解。

## 如何操作

在代码上很好实现离散化：先上一种Hash离散

```cpp
for(int i=1;i<=n;i++){
    cin>>A[i];            //原表
  	B[i]=A[i];            //原表复制
}
sort(B+1,b+1+n);
for(int i=1;i<=n;i++){
    pos=lower_bound(B+1,B+1+n,A[i])-B;        //pos即离散后的位置
  	C[pos]=A[i];
}
```

但是上述方法有一点很尴尬，就是不支持原数据重复，优化一下：

```cpp
int HASH[N];
for(int i=1;i<=n;i++){
    cin>>A[i];
  	HASH[i]=A[i];
}
sort(HASH+1,HASH+n+1);
int d=unique(HASH+1,HASH+n+1)-HASH-1;       //d是离散后表的长度，unique去重。
for(int i=1;i<=n;i++){
    int pos=lower_bound(HASH+1,HASH+d+1,A[i])-HASH;
}
```

完美实现了离散，其实总体来说，这些方法需要知道，但是最重要的还是实际应用在做题上，其实也可以说是，因为刷题才出现这些思想。

好像有一些简短诶，可是关于离散化的我也就了解这么多，有大神在讲离散化线段树，（本巨弱：线段树是什么啊…）

## 总结

思想源于题目，其实总结这句话只是来凑数的。