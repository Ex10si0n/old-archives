---
title: 「数论」Eratosthenes筛法和欧拉筛
date: 2017-06-16 22:46
tags: [数论]
categories: C++
thumbnail: http://i4.bvimg.com/1949/37c24a81c699b09bt.jpg
---
## 前言

我们今天要研究快速求质数的算法，比起普通的普通判断方法，今天所讲的方法更加的快速高效，如何判断质数在此不加赘述，请您往下看：
## Eratosthenes筛法

Eratosthenes筛法又称普筛，易于初学者学习，因为其原理简单，代码简短实现容易，所以我看今天的时间不多，就给大家详细讲一讲Eratosthenes筛法。
下面，进入正题：
>Eratosthenes筛法是一种用于筛范围质数的一种高效的算法

我们拿出一串正整数
>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ...

接下来的操作就很关键了：
首先，我们从2开始，删掉队列中的所有2的倍数。
然后从下一位没有被筛掉的数（即存在于当前表中的下一个数）开始筛掉它的n倍(n≥2)，以此类推，让我们看一下效果。
>1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ...
>1 2 3  5  7  9 11  13  15  17  19  21  23 ...
>1 2 3  5  7   11  13    17  19    23 ...

我们去掉1来看一下，2 3 5 7 11 13 17 19 23 ...这几个被筛过保留的数都是质数了，就是因为，对于每个合数，都会被其所有质因子所筛掉，值得一提的是，我们对于任意一个正在处理的数，只需要筛选到√(你需要的质数范围)（即√(m)），原理和判断质数一样，只不过是打了一个质数表来保存区间质数。

对于筛的过程我们可以这样写：

```cpp
//Eratosthenes
memset(check,true,sizeof(check));
check[0]=check[1]=false;
	for(int i=1;i<=1000001;i++){
			for(int j=i*2;j<=sqrt(m);j+=i) check[j]=false;
			//被筛掉
	}
```
而埃氏筛依旧有一些效率不高的地方，我们会发现，当我们针对于当前循环到达的i这个数时，i的所有倍数都会被筛掉，那么比如2筛掉了4 6 8 10 12 16... ，4筛掉了8 12 16 ... ，我们并没有因为这个数被筛掉了而跳过筛除这个数的倍数，或许你加一句判断可以阻止这种情况的发生，但是我们判断也是花费时间的。所以我们需要理解一种更加高效的筛法：欧拉筛。

## 欧拉筛

先说一下欧拉筛的实现，欧拉筛需要在筛的过程中生成一个质数表来存放判断出来的质数（这些质数以后是要用得上的），我们想实现：
>对于每个合数，都只被其最小质因子筛除。

这就可以实现每个数都被筛掉一次，下面我来解释一下这个过程：
>初始状态
>
>当前数：(空)
>质数表：(空)
>check表：2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28

初始状态check表都是1～n的整数
>第一次
>
>当前数：2
>质数表：2
>本次被筛掉的数：2x2=4
>check表：3 * 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28

我们仔细看一下过程：2被判断为质数，i从2开始直到2的最小质因子筛掉了2的当前数倍。有可能不太好理解，那么我们继续筛：
>第二次
>
>当前数：3
>质数表：2 3
>本次被筛掉的数：3x2=6 3x3=9
>check表：5 * 7 8 * 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28

可以看到，当前数走到了3，我们筛出去i（1~当前数的最小质因子）的 3 (当前数为3) 的倍数。

>第三次
>
>当前数：4
>质数表：2 3
>本次被筛掉的数：2x4=8
>check表：5 7 * 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28

此次4不是质数（被vis [ ]判断为合数，因为4在第一次被筛掉了），不加入质数表。并且，12的最小质因子是2，所以本轮不能用3筛掉它。

>第四次
>
>当前数：5
>质数表：2 3 5
>本次被筛掉的数：2x5=10 3x5=15 5x5=25
>check表：7 * 11 13 14 * 16 17 18 19 20 21 22 23 24 * 26 27 28

>第五次
>
>当前数：6
>质数表：2 3 5
>本次被筛掉的数：2x6=12 
>check表：7 * 11 13 14 16 17 18 19 20 21 22 23 24 26 27 28
>
>第六次
>
>当前数：7
>质数表：2 3 5 7
>本次被筛掉的数：2x7=14 3x7=21 5x7=35 7x7=49
>check表：11 13 16 17 18 19 20 22 23 24 26 27 28

接下来就不往下写了，请大家仔细阅读欧拉筛的代码，实现的就是这么一回事儿，只不过用了几个很巧妙的点：
>if ( i % PrimeTable [ j ] == 0) 判断最小质因子
>



```cpp
//代码来自 http://blog.csdn.net/ggn_2015/article/details/68059353
//Eurler
bool vis[1000000001];//记录一个数当前是否被"筛出"过
int PrimeCount=0;//记录当前质数表的大小
int PrimeTable[50847537];//质数表，你可能会感觉我定义的内存可能有点少，实则不然
//因为我是预先知道10^9以内的素数的个数的
void AddPrime(int thePrime)//向质数表中添加一个质数
{
    PrimeTable[++PrimeCount]=thePrime;
}
void PrimeSelect(int maxNum)//欧拉筛法
{
    vis[0]=vis[1]=vis[2]=1;
    AddPrime(2);//把2加到质数表
    for(int i=3;i<=maxNum;i++)
    {
        if(!vis[i])//如果这个结点仍未被"筛出"
            AddPrime(i);//把它加入质数表
        vis[i]=1;//把这个数筛出
        for(int j=1;j<=PrimeCount && i*PrimeTable[j]<=maxNum;j++)
        {
            vis[i*PrimeTable[j]]=1;//把 这个数 与 所有已知质数 的积 "筛出"
            if(i%PrimeTable[j]==0)//关键在这里,判断出最小质因子
                break;
        }
    }

}
```
## 结束语

今天忙活的也挺累的了，我也是事先巩固了一遍欧拉筛，怕给大家讲糊涂了，希望我写的那几步能让您更好的理解欧拉筛的运行机制，今天到此结束吧，拜拜！



